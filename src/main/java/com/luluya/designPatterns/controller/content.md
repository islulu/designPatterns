#设计模式#
0. 反射：正在运行,动态获取这个类的所有信息;
    作用:
       1.反编译：.class-->.java
       2.通过反射机制访问java对象的属性，方法，构造方法等；
    优点: 
        提高程序扩展性
    应用场景：
        Jdbc加载驱动;SpringIOC;框架
    反射机制获取类的方法：
        //第一种方式： 
        Classc1 = Class.forName("Employee");  
        //第二种方式：java中每个类型都有class 属性.  
        Classc2 = Employee.class;  
        //第三种方式：java语言中任何一个java对象都有getClass 方法  
        Employeee = new Employee();  
        Classc3 = e.getClass(); //c3是运行时类 (e的运行时类是Employee)  
    反射创建对象的方式:
        实例化无参构造函数
            Class<?> forName = Class.forName("com.itmayiedu.entity.User");
            // 创建此Class 对象所表示的类的一个新实例 调用了User的无参数构造方法.
            Object newInstance = forName.newInstance();
        实例化有参构造函数
            Class<?> forName = Class.forName("com.itmayiedu.entity.User");
            Constructor<?> constructor = forName.getConstructor(String.class, String.class);
            User newInstance = (User) constructor.newInstance("123", "123");
    反射创建api：
        方法名称	                作用
        getDeclaredMethods[]	获取该类的所有方法
        getReturnType()	        获取该类的返回值
        getParameterTypes()	    获取传入参数
        getDeclaredFields()	    获取该类的所有字段
        setAccessible	        允许访问私有成员
    
1. 设计模式
    优点：
        方便维护、重构代码、扩展性、减少冗余代码、降低耦合度
    六大原则:
        开闭原则（Open Close Principle）
            对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。
            即：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，需要使用接口和抽象类。
        里氏代换原则（Liskov Substitution Principle）
            面向对象设计的基本原则之一。 任何基类可以出现的地方，子类一定可以出现。 
            LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。
            里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
        依赖倒转原则（Dependence Inversion Principle）
            开闭原则的基础，即：真对接口编程，依赖于抽象而不依赖于具体。
        接口隔离原则（Interface Segregation Principle）
            使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。
            所以上文中多次出现：降低依赖，降低耦合。
        迪米特法则（最少知道原则）（Demeter Principle）
            一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
        合成复用原则（Composite Reuse Principle）
            原则是尽量使用合成/聚合的方式，而不是使用继承。
    设计模式分类:
            创建型模式，共五种：*单例模式、*工厂方法模式、*抽象工厂模式、*原型模式、建造者模式。
            结构型模式，共七种：*适配器模式、*装饰器模式、*代理模式、*外观模式、*组合模式、桥接模式、享元模式。
            行为型模式，共十一种：*策略模式、*模板方法模式、*观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
            
2. 单例模式
    保证在一个jvm中，只存在一个实例，只初始化一次，保证对象唯一性。
    应用场景：
        servlet、springMVC、连接池、线程池、Spring（默认）、枚举、常量
    好处：节约内存、重复利用、方便管理; 
        1.防止其它对象对自己的实例化，确保所有的对象都访问一个实例(防止其它对象对自己的实例化，确保所有的对象都访问一个实例)
        2.具有一定的伸缩性，类自己来控制实例化进程
        3.提供了对唯一实例的受控访问
        4.系统内存中只存在一个对象，so节约系统资源(当需要频繁创建和销毁的对象时可提高系统的性能)
        5.允许可变数目的实例
        6.避免对共享资源的多重占用
    缺点：线程安全问题
        1.不适用于变化的对象(同一类型对象总是要在不同的用例场景发生变化，不能保存彼此的状态，造成单例就会引起数据的错误)
        2.没有抽象层，单例类的扩展有很大的困难
        3.单例类的职责过重，在一定程度上违背了“单一职责原则”
        4.滥用单例将带来一些负面问题
            (a.节省资源将数据库连接池对象设计为的单例类;
             b.导致共享连接池对象的程序过多而出现连接池溢出;
             c.如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失)
    7种创建方式：
        1.饿汉式:
            类初始化时,会立即加载该对象，线程天生安全,调用效率高。（线程安全
        2.懒汉式: 
            类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。（线程不安全
             优点：结合了懒汉模式的内存优化（使用时才初始化）以及饿汉模式的安全性（不会被反射入侵，加载类是线程安全的）
            缺点：需要两个类去做到这一点，虽然不会创建静态内部类的对象，但是其 Class 对象还是会被创建，而且是属于永久带的对象。
        4.枚举单例: 
            使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞，缺点没有延迟加载。
        5.双重检测锁方式：（不推荐使用
            因为JVM本质重排序的原因，可能会初始化多次。
    如何选择单例创建方式：
        最好使用饿汉式，开发过程中使用较多（加载配置文件/Spring...
        定义过多常量，会导致内存溢出。
        如果不需要延迟加载单例：使用枚举或者饿汉式（相对来说枚举性好于饿汉式
        如果需要延迟加载：使用静态内部类/懒韩式（相对来说静态内部类好于懒汉式
        
        *** 事务失效之迷！！！（代理模式）

3. 工厂模式：简单工厂（非23种设计模式之一）、工厂方法、抽象工厂方法
    最常用的实例化对象模式，实现了创建者和调用中分离
    好处：降低耦合性，便于后期维护
    将选择实现类、创建对象统一管理和控制,将调用者跟实现类解耦
    - 简单工厂：用于生产同一等级结构中的任意产品（不支持拓展增加产品）
        优点：根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化
        缺点：集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则（工厂职责过重，如果类型过多则不利于系统扩展维护
    - 工厂方法：用于生产同一等级结构中的固定产品（支持拓展增加产品
        根据对象进行分类 创建多个工厂（核心类是一个抽象工厂角色）  
    - 抽象工厂方法：用于生产不同产品族的全部产品（不支持拓展增加产品，支持增加产品族
    
4. 代理模式(重构代码)(切面编程、事务)
    - 最大亮点：通过代理控制对象的访问,可以详细访问某个对象的方法，在这个方法调用处理前或调用后处理。
    - 使用场景：SpringAOP、事物原理、日志打印、权限控制、远程调用、安全代理 可以隐蔽真实角色
    - 分类：
        静态代理(静态定义代理类):不建议使用
            
        动态代理(动态生成代理类):
            1.代理对象,不需要实现接口
            2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
            3.动态代理也叫做:JDK代理,接口代理
            
            a.Jdk动态代理:
               根据类加载器和接口创建代理类（此代理类是接口的实现类，所以 *必须使用接口* 面向接口生成代理，位于java.lang.reflect包下）
               缺点：jdk动态代理必须是面向接口，目标业务类必须实现接口
            b.Cglib 、javaassist（字节码操作库）:
                利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。 
                使用cglib[Code Generation Library]实现动态代理，并 *不要求委托类* 必须实现接口，底层采用asm字节码生成框架生成代理类的字节码

            * CGLIB动态代理与JDK动态区别
            java动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
            cglib动态代理：利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
            
            Spring中。
            1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 
            2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 
            3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换
            
            JDK动态代理只能对实现了接口的类生成代理，而不能针对类 。
            CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 。
            因为是继承，所以该类或方法最好不要声明成final ，final可以阻止继承和多态。

5. 建造者模式
    - 是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    - 使用场景：
        1、需要生成的对象具有复杂的内部结构。 
        2、需要生成的对象内部属性本身相互依赖。
        与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。
        
        eg：1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。
            2、JAVA 中的StringBuilder数组（单个字符）字整合在一起 字符串

    - 工厂类模式：提供的是创建单个类的模式
      建造者模式：将各种产品集中起来进行管理，用来创建复合对象（复合对象就是指某个类具有不同的属性，就是前面抽象工厂模式和最后的Test结合起来得到的）
      
6. 模版方法
    - 定义一个操作中的算法骨架，而将一些步骤延迟到子类中。
    - 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的重复代码全部在父类里面，不同业务的，抽取给子类进行实现。抽取过程---抽象方法。
        即：将一些相同操作的代码，封装成一个算法的骨架。核心的部分留在子类中操作，在父类中只把那些骨架做好。
    应用场景：
        数据库访问的封装、Junit单元测试、servlet中关于doGet/doPost方法的调用
        Hibernate中模板程序、spring中JDBCTemplate，HibernateTemplate等等
        
        即：实现一些操作时，整体步骤很固定，但是呢。就是其中一小部分容易变，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。
        
7. 适配器模式
    - 一个适配使得因接口不兼容而不能在一起工作的类工作在一起（将类自己的接口包裹在一个已存在的类中）
    - 分类：类适配器、对象适配、接口适配方式（类适配器方式采用继承方式，对象适配方式使用构造函数传递）
    - 使用场景：
        1、在使用第三方的类库，或者说第三方的API的时候，我们通过适配器转换来满足现有系统的使用需求。
        2、旧系统与新系统进行集成的时候，我们发现旧系统的数据无法满足新系统的需求，那么这个时候，我们可能需要适配器，完成调用需求。
        3、在使用不同数据库之间进行数据同步。(我这里只是分析的是通过程序来说实现的时候的情况。还有其他的很多种方式 数据库同步)。
        
        eg：OutputStreamWriter：是Writer的子类，将输出的字符流变为字节流，即：将一个字符流的输出对象变为字节流的输出对象。
            InputStreamReader：是Reader的子类，将输入的字节流变为字符流，即：将一个字节流的输入对象变为字符流的输入对象。
            SpringMVC 适配器
            
8. 外观模式
    门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。
    提供了客户端请求的简化方法和对现有系统类方法的委托调用。

9. 原型模式（克隆
    - 用户从这个样板对象中复制一个内部属性一致的对象 -->“克隆”。被复制的实例 --> “原型”(是可定制的)
      原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。
    - 应用场景:
        （1）类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗。 
        （2）通过new产生的一个对象需要非常繁琐的数据准备或者权限，这时可以使用原型模式。 
        （3）一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。
        Spring框架中的多例就是使用原型。
    - 使用方式：
        原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件： 
    　　（1）实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。
            在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。 
    　　（2）重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，
            作用是返回对象的一个拷贝，但其作用域protected类型的，一般的类无法调用，因此Prototype类需要将clone方法的作用域修改为public类型。
    - 原型模式分为浅复制和深复制
        浅复制：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。
        深复制：在计算机中开辟了一块新的内存地址用于存放复制的对象。

10. 策略模式
    - 定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。
    - 应用场景：
        策略模式的用意是针对一组算法或逻辑，将每一个算法或逻辑封装到具有共同接口的独立的类中，从而使得它们之间可以相互替换。
        策略模式使得算法或逻辑可以在不影响到客户端的情况下发生变化。
        说到策略模式就不得不提及OCP(Open Closed Principle) 开闭原则，即对扩展开放，对修改关闭。
        策略模式的出现很好地诠释了开闭原则，有效地减少了分支语句。

11. 装饰模式(包装模式)
    - 对已经存在的某些类进行装饰，以此来扩展一些功能
    - 装饰与代理区别
        装饰器模式：关注于在一个对象上动态的添加方法
        代理模式：关注于控制对对象的访问
        即：
        使用代理模式：代理类（proxy class）可以对它的客户隐藏一个对象的具体信息，so 使用代理模式的时候常常在一个代理类中创建一个对象的实例。
        使用装饰器模式：通常是将原始对象作为一个参数传给装饰者的构造器。
    - 应用场景
        在IO中，具体构件角色是节点流，装饰角色是过滤流。
        FilterInputStream和FilterOutputStream是装饰角色，而其他派生自它们的类则是具体装饰角色。
        DataoutputStream out=new DataoutputStream(new FileoutputStream());
        这就是 装饰者模式，DataoutputStream是装饰者子类，FileoutputStream是实现接口的子类。
        这里不会调用到装饰者类--FilteroutputStream,只是作为继承的另一种方案，对客户端来说是透明的，是为了功能的扩张.
    
12. 观察者模式
    - 关注的是系统中对象之间的相互交互，解决系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。
      相比来说，创建型模式关注对象的创建过程，结构型模式关注对象和类的组合关系。
    - 模式的职责
      观察者模式主要用于1对N的通知。当一个对象的状态变化时，他需要及时告知一系列对象，令他们做出相应。 
      实现有两种方式： 
          推：每次都会把通知以广播的方式发送给所有观察者，所有的观察者只能被动接收。 
          拉：观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定。
    - 应用场景
      关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。
      事件多级触发场景。
      跨系统的消息交换场景，如消息队列、事件总线的处理机制。

















